From de5b86774fe1bee13f2cc1c171f28e20d65ea240 Mon Sep 17 00:00:00 2001
From: Alexandru Costache <alexandru@balena.io>
Date: Fri, 4 Nov 2022 15:22:25 +0100
Subject: [PATCH] drivers/bluetooth/realtek: Update rtk_bt to 5.12.1.8

As requested in internal thread
https://jel.ly.fish/support-thread-1-0-0-front-cnv-d2dnnyl

Upstream-status: Inappropriate [backport]
Signed-off-by: Alexandru Costache <alexandru@balena.io>
---
 nvidia/drivers/bluetooth/realtek/rtk_bt.c   | 200 +++++-
 nvidia/drivers/bluetooth/realtek/rtk_bt.h   |   4 +
 nvidia/drivers/bluetooth/realtek/rtk_coex.c |  44 +-
 nvidia/drivers/bluetooth/realtek/rtk_coex.h |   1 +
 nvidia/drivers/bluetooth/realtek/rtk_misc.c | 638 +++++++++++---------
 nvidia/drivers/bluetooth/realtek/rtk_misc.h |  24 +-
 6 files changed, 598 insertions(+), 313 deletions(-)

diff --git a/nvidia/drivers/bluetooth/realtek/rtk_bt.c b/nvidia/drivers/bluetooth/realtek/rtk_bt.c
index 893ca1c1136b..d2df61e93c67 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_bt.c
+++ b/nvidia/drivers/bluetooth/realtek/rtk_bt.c
@@ -35,7 +35,7 @@
 #include "rtk_bt.h"
 #include "rtk_misc.h"
 
-#define VERSION "3.1"
+#define VERSION "3.1.523c92e.20210706-141239"
 
 #ifdef BTCOEX
 #include "rtk_coex.h"
@@ -81,6 +81,62 @@ static struct usb_device_id btusb_table[] = {
 		.bInterfaceClass = 0xe0,
 		.bInterfaceSubClass = 0x01,
 		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x04ca,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x2ff8,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x0b05,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x0930,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x10ec,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x04c5,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x0cb5,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
+	}, {
+		.match_flags = USB_DEVICE_ID_MATCH_VENDOR |
+			USB_DEVICE_ID_MATCH_INT_INFO,
+		.idVendor = 0x0cb8,
+		.bInterfaceClass = 0xe0,
+		.bInterfaceSubClass = 0x01,
+		.bInterfaceProtocol = 0x01
 	}, { }
 };
 
@@ -1037,6 +1093,9 @@ static void btusb_notify(struct hci_dev *hdev, unsigned int evt)
 	if (SCO_NUM != data->sco_num) {
 		data->sco_num = SCO_NUM;
 		RTKBT_DBG("%s: Update sco num %d", __func__, data->sco_num);
+#if HCI_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
+		data->air_mode = evt;
+#endif
 		schedule_work(&data->work);
 	}
 }
@@ -1086,12 +1145,70 @@ static inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)
 	return 0;
 }
 
+#if HCI_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
+static int btusb_switch_alt_setting(struct hci_dev *hdev, int new_alts)
+{
+	struct btusb_data *data = hci_get_drvdata(hdev);
+	int err;
+
+	if (data->isoc_altsetting != new_alts) {
+		unsigned long flags;
+
+		clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+		usb_kill_anchored_urbs(&data->isoc_anchor);
+
+		/* When isochronous alternate setting needs to be
+		 * changed, because SCO connection has been added
+		 * or removed, a packet fragment may be left in the
+		 * reassembling state. This could lead to wrongly
+		 * assembled fragments.
+		 *
+		 * Clear outstanding fragment when selecting a new
+		 * alternate setting.
+		 */
+		spin_lock_irqsave(&data->rxlock, flags);
+		kfree_skb(data->sco_skb);
+		data->sco_skb = NULL;
+		spin_unlock_irqrestore(&data->rxlock, flags);
+
+		err = __set_isoc_interface(hdev, new_alts);
+		if (err < 0)
+			return err;
+	}
+
+	if (!test_and_set_bit(BTUSB_ISOC_RUNNING, &data->flags)) {
+		if (btusb_submit_isoc_urb(hdev, GFP_KERNEL) < 0)
+			clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
+		else
+			btusb_submit_isoc_urb(hdev, GFP_KERNEL);
+	}
+
+	return 0;
+}
+
+static struct usb_host_interface *btusb_find_altsetting(struct btusb_data *data,
+							int alt)
+{
+	struct usb_interface *intf = data->isoc;
+	int i;
+
+	BT_DBG("Looking for Alt no :%d", alt);
+
+	for (i = 0; i < intf->num_altsetting; i++) {
+		if (intf->altsetting[i].desc.bAlternateSetting == alt)
+			return &intf->altsetting[i];
+	}
+
+	return NULL;
+}
+#endif
+
 static void btusb_work(struct work_struct *work)
 {
 	struct btusb_data *data = container_of(work, struct btusb_data, work);
 	struct hci_dev *hdev = data->hdev;
 	int err;
-	int new_alts;
+	int new_alts = 0;
 
 	RTKBT_DBG("%s: sco num %d", __func__, data->sco_num);
 	if (data->sco_num > 0) {
@@ -1108,7 +1225,22 @@ static void btusb_work(struct work_struct *work)
 
 			set_bit(BTUSB_DID_ISO_RESUME, &data->flags);
 		}
-#if HCI_VERSION_CODE > KERNEL_VERSION(3, 7, 1)
+#if HCI_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
+		if (data->air_mode == HCI_NOTIFY_ENABLE_SCO_CVSD) {
+			if (hdev->voice_setting & 0x0020) {
+				static const int alts[3] = { 2, 4, 5 };
+				new_alts = alts[data->sco_num - 1];
+			} else {
+				new_alts = data->sco_num;
+			}
+		} else if (data->air_mode == HCI_NOTIFY_ENABLE_SCO_TRANSP) {
+			new_alts = btusb_find_altsetting(data, 6) ? 6 : 1;
+		}
+
+		if (btusb_switch_alt_setting(hdev, new_alts) < 0)
+				RTKBT_ERR("set USB alt:(%d) failed!", new_alts);
+#else
+#if HCI_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
 		if (hdev->voice_setting & 0x0020) {
 			static const int alts[3] = { 2, 4, 5 };
 			new_alts = alts[data->sco_num - 1];
@@ -1136,6 +1268,7 @@ static void btusb_work(struct work_struct *work)
 			else
 				btusb_submit_isoc_urb(hdev, GFP_KERNEL);
 		}
+#endif
 	} else {
 		clear_bit(BTUSB_ISOC_RUNNING, &data->flags);
 		mdelay(URB_CANCELING_DELAY_MS);
@@ -1162,6 +1295,57 @@ static void btusb_waker(struct work_struct *work)
 	RTKBT_DBG("%s end", __FUNCTION__);
 }
 
+#ifdef RTKBT_TV_POWERON_WHITELIST
+static int rtkbt_lookup_le_device_poweron_whitelist(struct hci_dev *hdev,
+						struct usb_device *udev)
+{
+	struct hci_conn_params *p;
+	u8 *cmd;
+	int result = 0;
+
+	hci_dev_lock(hdev);
+	list_for_each_entry(p, &hdev->le_conn_params, list) {
+#if 0 // for debug message
+		RTKBT_DBG("%s(): auto_connect = %d", __FUNCTION__, p->auto_connect);
+		RTKBT_DBG("%s(): addr_type = 0x%02x", __FUNCTION__, p->addr_type);
+		RTKBT_DBG("%s(): addr=%02x:%02x:%02x:%02x:%02x:%02x", __FUNCTION__,
+                                p->addr.b[5], p->addr.b[4], p->addr.b[3],
+                                p->addr.b[2], p->addr.b[1], p->addr.b[0]);
+#endif
+		if ( p->auto_connect == HCI_AUTO_CONN_ALWAYS &&
+			p->addr_type == ADDR_LE_DEV_PUBLIC ) {
+
+			RTKBT_DBG("%s(): Set RTKBT LE Power-on Whitelist for "
+				"%02x:%02x:%02x:%02x:%02x:%02x", __FUNCTION__,
+                                p->addr.b[5], p->addr.b[4], p->addr.b[3],
+                                p->addr.b[2], p->addr.b[1], p->addr.b[0]);
+
+			cmd = kzalloc(16, GFP_ATOMIC);
+			if (!cmd) {
+				RTKBT_ERR("Can't allocate memory for cmd");
+				return -ENOMEM;
+			}
+			cmd[0] = 0x7b;
+			cmd[1] = 0xfc;
+			cmd[2] = 0x07;
+			cmd[3] = 0x00;
+			cmd[4] = p->addr.b[0];
+			cmd[5] = p->addr.b[1];
+			cmd[6] = p->addr.b[2];
+			cmd[7] = p->addr.b[3];
+			cmd[8] = p->addr.b[4];
+			cmd[9] = p->addr.b[5];
+
+			result = __rtk_send_hci_cmd(udev, cmd, 10);
+			kfree(cmd);
+		}
+	}
+	hci_dev_unlock(hdev);
+
+	return result;
+}
+#endif
+
 int rtkbt_pm_notify(struct notifier_block *notifier,
 		    ulong pm_event, void *unused)
 {
@@ -1170,9 +1354,11 @@ int rtkbt_pm_notify(struct notifier_block *notifier,
 	struct usb_interface *intf;
 	struct hci_dev *hdev;
 	/* int err; */
+#if defined RTKBT_SWITCH_PATCH || defined RTKBT_TV_POWERON_WHITELIST
+	int result = 0;
+#endif
 #ifdef RTKBT_SWITCH_PATCH
 	u8 *cmd;
-	int result;
 	static u8 hci_state = 0;
 	struct api_context ctx;
 #endif
@@ -1258,6 +1444,12 @@ int rtkbt_pm_notify(struct notifier_block *notifier,
 		/* Send special vendor commands */
 #endif
 
+#ifdef RTKBT_TV_POWERON_WHITELIST
+		result = rtkbt_lookup_le_device_poweron_whitelist(hdev, udev);
+		if (result < 0) {
+			RTKBT_ERR("rtkbt_lookup_le_device_poweron_whitelist error: %d", result);
+		}
+#endif
 		break;
 
 	case PM_POST_SUSPEND:
diff --git a/nvidia/drivers/bluetooth/realtek/rtk_bt.h b/nvidia/drivers/bluetooth/realtek/rtk_bt.h
index 4aec3154f211..02cc884bf93c 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_bt.h
+++ b/nvidia/drivers/bluetooth/realtek/rtk_bt.h
@@ -135,6 +135,10 @@ struct btusb_data {
 	__u8 cmdreq_type;
 
 	unsigned int sco_num;
+
+#if HCI_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
+	unsigned int air_mode;
+#endif
 	int isoc_altsetting;
 	int suspend_count;
 
diff --git a/nvidia/drivers/bluetooth/realtek/rtk_coex.c b/nvidia/drivers/bluetooth/realtek/rtk_coex.c
index 9a987a501b70..ed2838671adb 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_coex.c
+++ b/nvidia/drivers/bluetooth/realtek/rtk_coex.c
@@ -1,7 +1,5 @@
 /*
 *
-* Copyright (c) 2019-2020, NVIDIA CORPORATION. All rights reserved.
-*
 *  Realtek Bluetooth USB driver
 *
 *
@@ -59,13 +57,10 @@
 
 #define RTK_VERSION "1.2"
 
-#define RTKBT_DBG(fmt, arg...) \
-			printk(KERN_DEBUG "rtk_btcoex: " fmt "\n" ,## arg)
+#define RTKBT_DBG(fmt, arg...) printk(KERN_INFO "rtk_btcoex: " fmt "\n" , ## arg)
 #define RTKBT_INFO(fmt, arg...) printk(KERN_INFO "rtk_btcoex: " fmt "\n" , ## arg)
-#define RTKBT_WARN(fmt, arg...) \
-			printk( KERN_DEBUG "rtk_btcoex: " fmt "\n" ,## arg)
-#define RTKBT_ERR(fmt, arg...) \
-			printk(KERN_DEBUG "rtk_btcoex: " fmt "\n", ## arg)
+#define RTKBT_WARN(fmt, arg...) printk(KERN_WARNING "rtk_btcoex: " fmt "\n", ## arg)
+#define RTKBT_ERR(fmt, arg...) printk(KERN_WARNING "rtk_btcoex: " fmt "\n", ## arg)
 
 static struct rtl_coex_struct btrtl_coex;
 
@@ -1891,7 +1886,7 @@ static void rtk_handle_connection_complete_evt(u8 * p)
 	}
 }
 
-static void rtk_handle_le_connection_complete_evt(u8 * p)
+static void rtk_handle_le_connection_complete_evt(u8 enhanced, u8 * p)
 {
 	u16 handle, interval;
 	u8 status;
@@ -1899,7 +1894,10 @@ static void rtk_handle_le_connection_complete_evt(u8 * p)
 
 	status = *p++;
 	STREAM_TO_UINT16(handle, p);
-	p += 8;			//role, address type, address
+	if (!enhanced)
+		p += 8;	/* role, address type, address */
+	else
+		p += (8 + 12); /* plus two bluetooth addresses */
 	STREAM_TO_UINT16(interval, p);
 
 	RTKBT_INFO("LE connected, handle %04x, status 0x%02x, interval %u",
@@ -1970,7 +1968,10 @@ static void rtk_handle_le_meta_evt(u8 * p)
 	u8 sub_event = *p++;
 	switch (sub_event) {
 	case HCI_EV_LE_CONN_COMPLETE:
-		rtk_handle_le_connection_complete_evt(p);
+		rtk_handle_le_connection_complete_evt(0, p);
+		break;
+	case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
+		rtk_handle_le_connection_complete_evt(1, p);
 		break;
 
 	case HCI_EV_LE_CONN_UPDATE_COMPLETE:
@@ -2036,8 +2037,7 @@ static void disconn_acl(u16 handle, struct rtl_hci_conn *conn)
 
 	list_for_each_safe(iter, temp, &coex->profile_list) {
 		prof_info = list_entry(iter, rtk_prof_info, list);
-		if (handle == prof_info->handle && prof_info->scid
-		    && prof_info->dcid) {
+		if (handle == prof_info->handle) {
 			RTKBT_DBG("hci disconn, hndl %x, psm %x, dcid %x, "
 				  "scid %x, profile %u", prof_info->handle,
 				  prof_info->psm, prof_info->dcid,
@@ -2373,9 +2373,9 @@ static void rtl_ev_work(struct work_struct *work)
 	spin_unlock_irqrestore(&coex->buff_lock, flags);
 }
 
-int ev_filter_out(u8 ev_code)
+int ev_filter_out(u8 *buf)
 {
-	switch (ev_code) {
+	switch (buf[0]) {
 	case HCI_EV_INQUIRY_COMPLETE:
 	case HCI_EV_PIN_CODE_REQ:
 	case HCI_EV_IO_CAPA_REQUEST:
@@ -2387,9 +2387,19 @@ int ev_filter_out(u8 ev_code)
 	case HCI_EV_CONN_COMPLETE:
 	case HCI_EV_SYNC_CONN_COMPLETE:
 	case HCI_EV_DISCONN_COMPLETE:
-	case HCI_EV_LE_META:
 	case HCI_EV_VENDOR_SPECIFIC:
 		return 0;
+	case HCI_EV_LE_META:
+		/* Ignore frequent but not useful events that result in
+		 * costing too much space.
+		 */
+		switch (buf[2]) {
+		case HCI_EV_LE_CONN_COMPLETE:
+		case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
+		case HCI_EV_LE_CONN_UPDATE_COMPLETE:
+			return 0;
+		}
+		return 1;
 	default:
 		return 1;
 	}
@@ -2399,7 +2409,7 @@ static void rtk_btcoex_evt_enqueue(__u8 *s, __u16 count)
 {
 	struct rtl_hci_ev *ev;
 
-	if (ev_filter_out(s[0]))
+	if (ev_filter_out(s))
 		return;
 
 	ev = rtl_ev_node_get(&btrtl_coex);
diff --git a/nvidia/drivers/bluetooth/realtek/rtk_coex.h b/nvidia/drivers/bluetooth/realtek/rtk_coex.h
index 51ce3bc46f68..5b0ec85f0c60 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_coex.h
+++ b/nvidia/drivers/bluetooth/realtek/rtk_coex.h
@@ -47,6 +47,7 @@
 #define HCI_EV_LE_META			                        0x3e
 #define HCI_EV_LE_CONN_COMPLETE		                    0x01
 #define HCI_EV_LE_CONN_UPDATE_COMPLETE	                0x03
+#define HCI_EV_LE_ENHANCED_CONN_COMPLETE    0x0a
 
 //vendor cmd to fw
 #define HCI_VENDOR_ENABLE_PROFILE_REPORT_COMMAND        0xfc18
diff --git a/nvidia/drivers/bluetooth/realtek/rtk_misc.c b/nvidia/drivers/bluetooth/realtek/rtk_misc.c
index 3cffd75948ab..28c5174362e1 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_misc.c
+++ b/nvidia/drivers/bluetooth/realtek/rtk_misc.c
@@ -59,17 +59,13 @@
 
 #include "rtk_misc.h"
 
-#ifndef USE_CONTROLLER_BDADDR
 #include <linux/file.h>
 #include <linux/ctype.h>
 #define BDADDR_STRING_LEN	17
 #define BDADDR_FILE		"/opt/bdaddr"
-static bool customer_bdaddr = false;
-#endif
 
 struct cfg_list_item {
 	struct list_head list;
-	u8 *cfg_data;
 	u16 offset;
 	u8 len;
 	u8 data[0];
@@ -84,8 +80,6 @@ static struct list_head list_extracfgs;
 #define PKT_LEN			    300
 #define MSG_TO			    1000	//us
 #define PATCH_SEG_MAX	    252
-/* #define PATCH_LENGTH_MAX    24576 */ //24*1024
-#define PATCH_LENGTH_MAX	(40 * 1024)
 #define DATA_END		    0x80
 #define DOWNLOAD_OPCODE	    0xfc20
 /* This command is used only for TV patch
@@ -110,6 +104,7 @@ static struct list_head list_extracfgs;
 #define ROM_LMP_8821a               0X8821
 #define ROM_LMP_8761a               0X8761
 #define ROM_LMP_8822b               0X8822
+#define ROM_LMP_8852a               0x8852
 
 struct rtk_eversion_evt {
 	uint8_t status;
@@ -157,6 +152,11 @@ uint16_t project_id[] = {
 	ROM_LMP_NONE,
 	ROM_LMP_8822b, /* RTL8822CU */
 	ROM_LMP_8761a, /* index 14 for 8761BU */
+	ROM_LMP_NONE,
+	ROM_LMP_NONE,
+	ROM_LMP_NONE,
+	ROM_LMP_8852a, /* index 18 for 8852AU */
+	ROM_LMP_8723b, /* index 19 for 8723FU */
 };
 
 enum rtk_endpoit {
@@ -173,6 +173,8 @@ enum rtk_endpoit {
 #define RTL8821CU	0x72
 #define RTL8822CU	0x73
 #define RTL8761BU	0x74
+#define RTL8852AU	0x75
+#define RTL8723FU	0x76
 
 typedef struct {
 	uint16_t prod_id;
@@ -180,11 +182,6 @@ typedef struct {
 	char *	 mp_patch_name;
 	char *	 patch_name;
 	char *	 config_name;
-
-	/* TODO: Remove the following avariables */
-	uint8_t *fw_cache1;
-	int	 fw_len1;
-
 	u8       chip_type;
 } patch_info;
 
@@ -219,6 +216,7 @@ typedef struct {
 } __attribute__ ((packed)) download_rp;
 
 #define RTK_VENDOR_CONFIG_MAGIC 0x8723ab55
+const u8 cfg_magic[4] = { 0x55, 0xab, 0x23, 0x87 };
 struct rtk_bt_vendor_config_entry {
 	uint16_t offset;
 	uint8_t entry_len;
@@ -245,68 +243,148 @@ static int rcv_hci_evt(xchange_data * xdata);
 static uint8_t rtk_get_eversion(dev_data * dev_entry);
 
 static patch_info fw_patch_table[] = {
-/* { pid, lmp_sub, mp_fw_name, fw_name, config_name, fw_cache, fw_len } */
-	{0x1724, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* RTL8723A */
-	{0x8723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AE */
-	{0xA723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AE for LI */
-	{0x0723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AE */
-	{0x3394, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AE for Azurewave */
-
-	{0x0724, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AU */
-	{0x8725, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AU */
-	{0x872A, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AU */
-	{0x872B, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", NULL, 0},	/* 8723AU */
-
-	{0xb720, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723bu_config", NULL, 0},	/* RTL8723BU */
-	{0xb72A, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723bu_config", NULL, 0},	/* RTL8723BU */
-	{0xb728, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for LC */
-	{0xb723, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-	{0xb72B, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-	{0xb001, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for HP */
-	{0xb002, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-	{0xb003, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-	{0xb004, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-	{0xb005, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE */
-
-	{0x3410, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Azurewave */
-	{0x3416, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Azurewave */
-	{0x3459, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Azurewave */
-	{0xE085, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Foxconn */
-	{0xE08B, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Foxconn */
-	{0xE09E, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", NULL, 0},	/* RTL8723BE for Foxconn */
-
-	{0xA761, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU only */
-	{0x818B, 0x8761, "mp_rtl8761a_fw", "rtl8761aw_fw", "rtl8761aw_config", NULL, 0},	/* RTL8761AW + 8192EU */
-	{0x818C, 0x8761, "mp_rtl8761a_fw", "rtl8761aw_fw", "rtl8761aw_config", NULL, 0},	/* RTL8761AW + 8192EU */
-	{0x8760, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU + 8192EE */
-	{0xB761, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU + 8192EE */
-	{0x8761, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU + 8192EE for LI */
-	{0x8A60, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU + 8812AE */
-	{0x3527, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", NULL, 0},	/* RTL8761AU + 8814AE */
-
-	{0x8821, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-	{0x0821, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-	{0x0823, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AU */
-	{0x3414, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-	{0x3458, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-	{0x3461, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-	{0x3462, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", NULL, 0},	/* RTL8821AE */
-
-	{0xb82c, 0x8822, "mp_rtl8822bu_fw", "rtl8822bu_fw", "rtl8822bu_config", NULL, 0}, /* RTL8822BU */
-	{0xd723, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", NULL, 0}, /* RTL8723DU */
-	{0xb820, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", NULL, 0 }, /* RTL8821CU */
-	{0xc820, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", NULL, 0 }, /* RTL8821CU */
-
-	{0xc82c, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", NULL, 0 }, /* RTL8822CU */
-	{0xc822, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", NULL, 0 }, /* RTL8822CE */
-	{0xb00c, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", NULL, 0 }, /* RTL8822CE */
-	{0xc123, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", NULL, 0 }, /* RTL8822CE */
-	{0x3549, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", NULL, 0 }, /* RTL8822CE for Azurewave */
-
-	{0x8771, 0x8761, "mp_rtl8761bu_fw", "rtl8761bu_fw", "rtl8761bu_config", NULL, 0}, /* RTL8761BU only */
+/* { pid, lmp_sub, mp_fw_name, fw_name, config_name, chip_type } */
+	{0x1724, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* RTL8723A */
+	{0x8723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AE */
+	{0xA723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AE for LI */
+	{0x0723, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AE */
+	{0x3394, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AE for Azurewave */
+
+	{0x0724, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AU */
+	{0x8725, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AU */
+	{0x872A, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AU */
+	{0x872B, 0x1200, "mp_rtl8723a_fw", "rtl8723a_fw", "rtl8723a_config", RTLPREVIOUS},	/* 8723AU */
+
+	{0xb720, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BU */
+	{0xb72A, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BU */
+	{0xb728, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for LC */
+	{0xb723, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+	{0xb72B, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+	{0xb001, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for HP */
+	{0xb002, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+	{0xb003, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+	{0xb004, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+	{0xb005, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE */
+
+	{0x3410, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Azurewave */
+	{0x3416, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Azurewave */
+	{0x3459, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Azurewave */
+	{0xE085, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Foxconn */
+	{0xE08B, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Foxconn */
+	{0xE09E, 0x8723, "mp_rtl8723b_fw", "rtl8723b_fw", "rtl8723b_config", RTLPREVIOUS},	/* RTL8723BE for Foxconn */
+
+	{0xA761, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AU only */
+	{0x818B, 0x8761, "mp_rtl8761a_fw", "rtl8761aw_fw", "rtl8761aw_config", RTLPREVIOUS},	/* RTL8761AW + 8192EU */
+	{0x818C, 0x8761, "mp_rtl8761a_fw", "rtl8761aw_fw", "rtl8761aw_config", RTLPREVIOUS},	/* RTL8761AW + 8192EU */
+	{0x8760, 0x8761, "mp_rtl8761a_fw", "rtl8761au8192ee_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AU + 8192EE */
+	{0xB761, 0x8761, "mp_rtl8761a_fw", "rtl8761au_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AUV only */
+	{0x8761, 0x8761, "mp_rtl8761a_fw", "rtl8761au8192ee_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AU + 8192EE for LI */
+	{0x8A60, 0x8761, "mp_rtl8761a_fw", "rtl8761au8812ae_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AU + 8812AE */
+	{0x3527, 0x8761, "mp_rtl8761a_fw", "rtl8761au8192ee_fw", "rtl8761a_config", RTLPREVIOUS},	/* RTL8761AU + 8814AE */
+
+	{0x8821, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+	{0x0821, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+	{0x0823, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AU */
+	{0x3414, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+	{0x3458, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+	{0x3461, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+	{0x3462, 0x8821, "mp_rtl8821a_fw", "rtl8821a_fw", "rtl8821a_config", RTLPREVIOUS},	/* RTL8821AE */
+
+	{0xb82c, 0x8822, "mp_rtl8822bu_fw", "rtl8822bu_fw", "rtl8822bu_config", RTL8822BU}, /* RTL8822BU */
+
+	{0xd720, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", RTL8723DU}, /* RTL8723DU */
+	{0xd723, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", RTL8723DU}, /* RTL8723DU */
+	{0xd739, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", RTL8723DU}, /* RTL8723DU */
+	{0xb009, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", RTL8723DU}, /* RTL8723DU */
+	{0x0231, 0x8723, "mp_rtl8723du_fw", "rtl8723du_fw", "rtl8723du_config", RTL8723DU}, /* RTL8723DU for LiteOn */
+
+	{0xb820, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CU */
+	{0xc820, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CU */
+	{0xc821, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc823, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc824, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc825, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc827, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc025, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc024, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc030, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xb00a, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xb00e, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0xc032, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0x4000, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for LiteOn */
+	{0x4001, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for LiteOn */
+	{0x3529, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3530, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3532, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3533, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3538, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3539, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for Azurewave */
+	{0x3540, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE */
+	{0x3541, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for GSD */
+	{0x3543, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CE for GSD */
+	{0xc80c, 0x8821, "mp_rtl8821cu_fw", "rtl8821cu_fw", "rtl8821cu_config", RTL8821CU}, /* RTL8821CUH */
+
+	{0xc82c, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CU */
+	{0xc82e, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CU */
+	{0xc81d, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CU */
+	{0xc822, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc82b, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xb00c, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xb00d, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc123, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc126, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc127, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc128, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc129, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc131, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc136, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x3549, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE for Azurewave */
+	{0x3548, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE for Azurewave */
+	{0xc125, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x4005, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE for LiteOn */
+	{0x3051, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE for LiteOn */
+	{0x18ef, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x161f, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x3053, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc547, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x3553, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0x3555, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE */
+	{0xc82f, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE-VS */
+	{0xc02f, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE-VS */
+	{0xc03f, 0x8822, "mp_rtl8822cu_fw", "rtl8822cu_fw", "rtl8822cu_config", RTL8822CU}, /* RTL8822CE-VS */
+
+	{0x8771, 0x8761, "mp_rtl8761b_fw", "rtl8761bu_fw", "rtl8761bu_config", RTL8761BU}, /* RTL8761BU only */
+	{0xa725, 0x8761, "mp_rtl8761b_fw", "rtl8725au_fw", "rtl8725au_config", RTL8761BU}, /* RTL8725AU */
+	{0xa72A, 0x8761, "mp_rtl8761b_fw", "rtl8725au_fw", "rtl8725au_config", RTL8761BU}, /* RTL8725AU BT only */
+
+	{0x885a, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AU */
+	{0x8852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xa852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x2852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x385a, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x3852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x1852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x4852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x4006, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x3561, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x3562, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x588a, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x589a, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x590a, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xc125, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xe852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xb852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xc852, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xc549, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0xc127, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+	{0x3565, 0x8852, "mp_rtl8852au_fw", "rtl8852au_fw", "rtl8852au_config", RTL8852AU}, /* RTL8852AE */
+
+	{0xb733, 0x8723, "mp_rtl8723fu_fw", "rtl8723fu_fw", "rtl8723fu_config", RTL8723FU}, /* RTL8723FU */
+	{0xb73a, 0x8723, "mp_rtl8723fu_fw", "rtl8723fu_fw", "rtl8723fu_config", RTL8723FU}, /* RTL8723FU */
+	{0xf72b, 0x8723, "mp_rtl8723fu_fw", "rtl8723fu_fw", "rtl8723fu_config", RTL8723FU}, /* RTL8723FU */
 
 /* NOTE: must append patch entries above the null entry */
-	{0, 0, NULL, NULL, NULL, NULL, 0}
+	{0, 0, NULL, NULL, NULL, 0}
 };
 
 static LIST_HEAD(dev_data_list);
@@ -336,7 +414,7 @@ void util_hexdump(const u8 *buf, size_t len)
 	}
 }
 
-#ifdef RTKBT_SWITCH_PATCH
+#if defined RTKBT_SWITCH_PATCH || defined RTKBT_TV_POWERON_WHITELIST
 int __rtk_send_hci_cmd(struct usb_device *udev, u8 *buf, u16 size)
 {
 	int result;
@@ -460,7 +538,6 @@ static void line_process(char *buf, int len)
 
 	offset = simple_strtoul(argv[0], NULL, 16);
 	offset = offset | (simple_strtoul(argv[1], NULL, 16) << 8);
-	RTKBT_INFO("extra config offset %04lx", offset);
 	l = (u8)simple_strtoul(argv[2], NULL, 16);
 	if (l != (u8)(argc - 3)) {
 		RTKBT_ERR("invalid len %u", l);
@@ -474,7 +551,6 @@ static void line_process(char *buf, int len)
 		return;
 	}
 
-	item->cfg_data = item->data;
 	item->offset = (u16)offset;
 	item->len = l;
 	for (i = 0; i < l; i++)
@@ -619,12 +695,43 @@ static int send_reset_command(xchange_data *xdata)
 	return 0;
 }
 
+static inline int get_max_patch_size(u8 chip_type)
+{
+	int max_patch_size = 0;
+
+	switch (chip_type) {
+	case RTLPREVIOUS:
+		max_patch_size = 24 * 1024;
+		break;
+	case RTL8822BU:
+		max_patch_size = 25 * 1024;
+		break;
+	case RTL8723DU:
+	case RTL8822CU:
+	case RTL8761BU:
+	case RTL8821CU:
+		max_patch_size = 40 * 1024;
+		break;
+	case RTL8852AU:
+	case RTL8723FU:
+		max_patch_size = 40 * 1024 + 529;
+		break;
+	default:
+		max_patch_size = 40 * 1024;
+		break;
+	}
+
+	return max_patch_size;
+}
+
 int download_patch(struct usb_interface *intf)
 {
 	dev_data *dev_entry;
+	patch_info *pinfo;
 	xchange_data *xdata = NULL;
 	uint8_t *fw_buf;
 	int ret_val;
+	int max_patch_size = 0;
 
 	RTKBT_DBG("download_patch start");
 	dev_entry = dev_data_find(intf);
@@ -667,8 +774,16 @@ int download_patch(struct usb_interface *intf)
 
 	fw_buf = xdata->fw_data;
 
-	if (xdata->fw_len > PATCH_LENGTH_MAX) {
-		RTKBT_ERR("FW/CONFIG total length larger than allowed!");
+	pinfo = dev_entry->patch_entry;
+	if (!pinfo) {
+		RTKBT_ERR("%s: No patch entry", __func__);
+		ret_val = -1;
+		goto patch_fail;
+	}
+	max_patch_size = get_max_patch_size(pinfo->chip_type);
+	if (xdata->fw_len > max_patch_size) {
+		RTKBT_ERR("FW/CONFIG total length larger than allowed %d",
+			  max_patch_size);
 		ret_val = -1;
 		goto patch_fail;
 	}
@@ -766,9 +881,17 @@ int download_lps_patch(struct usb_interface *intf)
 
 	fw_buf = xdata->fw_data;
 
-	if (xdata->fw_len > PATCH_LENGTH_MAX) {
+	pinfo = dev_entry->patch_entry;
+	if (!pinfo) {
+		RTKBT_ERR("%s: No patch entry", __func__);
+		result = -1;
+		goto patch_fail;
+	}
+	max_patch_size = get_max_patch_size(pinfo->chip_type);
+	if (xdata->fw_len > max_patch_size) {
 		result = -1;
-		RTKBT_ERR("FW/CONFIG total length larger than allowed!");
+		RTKBT_ERR("FW/CONFIG total length larger than allowed %d",
+			  max_patch_size);
 		goto patch_fail;
 	}
 
@@ -854,31 +977,7 @@ dev_data *dev_data_find(struct usb_interface * intf)
 			patch_info *patch = dev_entry->patch_entry;
 			if (!patch)
 				return NULL;
-			switch (patch->prod_id){
-			case 0xb82c:
-				patch->chip_type = RTL8822BU;
-				break;
-			case 0xd723:
-				patch->chip_type = RTL8723DU;
-				break;
-			case 0xb820:
-			case 0xc820:
-				patch->chip_type = RTL8821CU;
-				break;
-			case 0xc82c:
-			case 0xc822:
-			case 0xb00c:
-			case 0xc123:
-			case 0x3549:
-				patch->chip_type = RTL8822CU;
-				break;
-			case 0x8771:
-				patch->chip_type = RTL8761BU;
-				break;
-			default:
-				patch->chip_type = RTLPREVIOUS;
-				break;
-			}
+
 			RTKBT_INFO("chip type value: 0x%02x", patch->chip_type);
 			return dev_entry;
 		}
@@ -907,7 +1006,7 @@ patch_info *get_patch_entry(struct usb_device * udev)
 	return patch_entry;
 }
 
-static int valid_mac(u8 chip_type, u16 offset)
+static int is_mac(u8 chip_type, u16 offset)
 {
 	int result = 0;
 
@@ -920,6 +1019,8 @@ static int valid_mac(u8 chip_type, u16 offset)
 		break;
 	case RTL8822CU:
 	case RTL8761BU:
+	case RTL8852AU:
+	case RTL8723FU:
 		if (offset == 0x0030)
 			return 1;
 		break;
@@ -932,104 +1033,94 @@ static int valid_mac(u8 chip_type, u16 offset)
 	return result;
 }
 
-static void fill_mac_offset(u8 chip_type, u8 b[2])
+static uint16_t get_mac_offset(u8 chip_type)
 {
 	switch (chip_type) {
 	case RTL8822BU:
 	case RTL8723DU:
 	case RTL8821CU:
-		b[0] = 0x44;
-		b[1] = 0x00;
-		break;
+		return 0x0044;
 	case RTL8822CU:
 	case RTL8761BU:
-		b[0] = 0x30;
-		b[1] = 0x00;
-		break;
+	case RTL8852AU:
+	case RTL8723FU:
+		return 0x0030;
 	case RTLPREVIOUS:
-		b[0] = 0x3c;
-		b[1] = 0x00;
-		break;
+		return 0x003c;
+	default:
+		return 0x003c;
 	}
 }
 
-static void merge_configs(uint8_t *cfg_buf, u16 *plen, int max)
+static void merge_configs(struct list_head *head, struct list_head *head2)
 {
-	struct list_head *iter, *tmp;
-	struct cfg_list_item *item;
-	u8 *buf;
-	u16 tmp_len;
+	struct list_head *epos, *enext;
+	struct list_head *pos, *next;
+	struct cfg_list_item *n;
+	struct cfg_list_item *extra;
 
-	list_for_each_safe(iter, tmp, &list_extracfgs) {
-		struct list_head *iter2, *tmp2;
+	if (!head || !head2)
+		return;
 
-		item = list_entry(iter, struct cfg_list_item, list);
-		list_for_each_safe(iter2, tmp2, &list_configs) {
-			struct cfg_list_item *n;
+	if (list_empty(head2))
+		return;
 
-			n = list_entry(iter2, struct cfg_list_item, list);
-			if (item->offset == n->offset) {
-				if (item->len == n->len) {
-					RTKBT_INFO("Update cfg: %04x, %u",
+	if (list_empty(head)) {
+		list_splice_tail(head2, head);
+		INIT_LIST_HEAD(head2);
+		return;
+	}
+
+	/* Add or update & replace */
+	list_for_each_safe(epos, enext, head2) {
+		extra = list_entry(epos, struct cfg_list_item, list);
+
+		list_for_each_safe(pos, next, head) {
+			n = list_entry(pos, struct cfg_list_item, list);
+			if (extra->offset == n->offset) {
+				if (extra->len < n->len) {
+					/* Update the cfg data */
+					RTKBT_INFO("Update cfg: ofs %04x len %u",
 						   n->offset, n->len);
-					memcpy(n->data, item->data, n->len);
-					if (n->cfg_data)
-						memcpy(n->cfg_data, item->data,
-						       n->len);
-					list_del(&item->list);
-					kfree(item);
-					break;
+					memcpy(n->data, extra->data,
+					       extra->len);
+					list_del(epos);
+					kfree(extra);
+				} else {
+					/* Replace the item */
+					list_del(epos);
+					list_replace_init(pos, epos);
+					/* free the old item */
+					kfree(n);
 				}
-
-				RTKBT_WARN("item mismatch %04x %u %u",
-					   item->offset, item->len, n->len);
-				list_del(&item->list);
-				kfree(item);
 			}
-		}
-	}
 
-	buf = cfg_buf + *plen;
-	list_for_each_safe(iter, tmp, &list_extracfgs) {
-		item = list_entry(iter, struct cfg_list_item, list);
-		if (item->len + 3 + *plen > max) {
-			RTKBT_WARN("%s: length %u exceeds %d", __func__,
-				   item->len + 3 + *plen, max);
-			goto done;
 		}
-		buf[0] = item->offset & 0xff;
-		buf[1] = (item->offset >> 8) & 0xff;
-		buf[2] = item->len;
-		memcpy(buf + 3, item->data, item->len);
-		buf += (3 + item->len);
-		*plen += (3 + item->len);
-		list_del(&item->list);
-		kfree(item);
-	}
 
-done:
-	tmp_len = *plen - 6;
+	}
 
-	cfg_buf[4] = (tmp_len & 0xff);
-	cfg_buf[5] = ((tmp_len >> 8) & 0xff);
+	if (list_empty(head2))
+		return;
+	list_for_each_safe(epos, enext, head2) {
+		extra = list_entry(epos, struct cfg_list_item, list);
+		RTKBT_INFO("Add new cfg: ofs %04x, len %u", extra->offset,
+			   extra->len);
+		/* Add the item to list */
+		list_del(epos);
+		list_add_tail(epos, head);
+	}
 }
 
-int rtk_parse_config_file(patch_info *pent, int max, u8 *config_buf,
-			  int filelen, char bt_addr[6])
+int rtk_parse_config_file(u8 *config_buf, int filelen)
 {
 	struct rtk_bt_vendor_config *config = (void *)config_buf;
 	u16 config_len = 0, temp = 0;
 	struct rtk_bt_vendor_config_entry *entry = NULL;
 	u32 i = 0;
-	char str[18];
-#ifndef USE_CONTROLLER_BDADDR
-	int j = 0;
-#endif
 	struct cfg_list_item *item;
-	u32 addr_found = 0;
 
-	if (!config)
-		return 0;
+	if (!config_buf)
+		return -EINVAL;
 
 	config_len = le16_to_cpu(config->data_len);
 	entry = config->entry;
@@ -1037,49 +1128,19 @@ int rtk_parse_config_file(patch_info *pent, int max, u8 *config_buf,
 	if (le32_to_cpu(config->signature) != RTK_VENDOR_CONFIG_MAGIC) {
 		RTKBT_ERR("sig magic num %08x,  not rtk vendor magic %08x",
 			  config->signature, RTK_VENDOR_CONFIG_MAGIC);
-		return 0;
+		return -1;
 	}
 
 	if (config_len != filelen - BT_CONFIG_HDRLEN) {
 		RTKBT_ERR("config length %u is not right %u", config_len,
 			  (u16)(filelen - BT_CONFIG_HDRLEN));
-		return 0;
+		return -1;
 	}
 
 	for (i = 0; i < config_len;) {
-		RTKBT_DBG("config offset %04x,length %02x", entry->offset,
-			  entry->entry_len);
-		switch (le16_to_cpu(entry->offset)) {
-		case 0x003c:
-		case 0x0044:
-		case 0x0030:
-#ifndef USE_CONTROLLER_BDADDR
-			if (!customer_bdaddr)
-				break;
-			if (!valid_mac(pent->chip_type, le16_to_cpu(entry->offset)))
-				break;
-			for (j = 0; j < entry->entry_len && j < 6; j++)
-				entry->entry_data[j] = bt_addr[j];
-#endif
-			addr_found = 1;
-			snprintf(str, sizeof(str),
-				 "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
-				 entry->entry_data[5],
-				 entry->entry_data[4],
-				 entry->entry_data[3],
-				 entry->entry_data[2],
-				 entry->entry_data[1],
-				 entry->entry_data[0]);
-			RTKBT_DBG("bdaddr sec found, set bdaddr %s", str);
-			break;
-		default:
-			break;
-		}
-
 		/* Add config item to list */
 		item = kzalloc(sizeof(*item) + entry->entry_len, GFP_KERNEL);
 		if (item) {
-			item->cfg_data = entry->entry_data;
 			item->offset = le16_to_cpu(entry->offset);
 			item->len = entry->entry_len;
 			memcpy(item->data, entry->entry_data, item->len);
@@ -1087,6 +1148,7 @@ int rtk_parse_config_file(patch_info *pent, int max, u8 *config_buf,
 		} else {
 			RTKBT_ERR("Cannot alloc mem for entry %04x, %u",
 				  entry->offset, entry->entry_len);
+			break;
 		}
 
 		temp = entry->entry_len +
@@ -1097,47 +1159,7 @@ int rtk_parse_config_file(patch_info *pent, int max, u8 *config_buf,
 							  temp);
 	}
 
-#ifndef USE_CONTROLLER_BDADDR
-	if (!addr_found && customer_bdaddr) {
-		u8 *b;
-		u16 ofs;
-
-		if (config_len + BT_CONFIG_HDRLEN + 9 > max) {
-			RTKBT_ERR("%s: length exceeds", __func__);
-		}
-
-		b = config_buf + config_len + BT_CONFIG_HDRLEN;
-		fill_mac_offset(pent->chip_type, b);
-		ofs = (((u16)b[1] << 8) | b[0]);
-		RTKBT_INFO("add bdaddr sec, offset %02x%02x", b[1], b[0]);
-		b[2] = 6;
-		for (j = 0; j < 6; j++)
-			b[3 + j] = bt_addr[j];
-
-		config_len += 9;
-
-		config_buf[4] = config_len & 0xff;
-		config_buf[5] = (config_len >> 8) & 0xff;
-
-		/* Add address item to list */
-		item = kzalloc(sizeof(*item) + 6, GFP_KERNEL);
-		if (item) {
-			item->cfg_data = b + 3;
-			item->offset = ofs;
-			item->len = b[2];
-			memcpy(item->data, b + 3, 6);
-			list_add_tail(&item->list, &list_configs);
-		} else {
-			RTKBT_ERR("Cannot alloc mem for entry %04x, %u",
-				  entry->offset, entry->entry_len);
-		}
-	}
-#endif
-
-	temp = config_len + BT_CONFIG_HDRLEN;
-	merge_configs(config_buf, &temp, max);
-
-	return temp;;
+	return 0;;
 }
 
 uint8_t rtk_get_fw_project_id(uint8_t * p_buf)
@@ -1224,7 +1246,6 @@ static void rtk_get_patch_entry(uint8_t * epatch_buf,
 		  tmp, (coex_ver & 0xffff));
 }
 
-#ifndef USE_CONTROLLER_BDADDR
 int bachk(const char *str)
 {
 	if (!str)
@@ -1307,24 +1328,29 @@ static int request_bdaddr(u8 *buf)
 fail:
 	return rc;
 }
-#endif
 
-static int load_config(dev_data *dev_entry, u8 **buf, int *length)
+static u8 *load_config(dev_data *dev_entry, int *length)
 {
 	patch_info *patch_entry;
 	const char *config_name;
 	const struct firmware *fw;
 	struct usb_device *udev;
 	int result;
-	u8 *tbuf;
-	int len;
+	u8 *buf;
+	u8 *p;
+	u16 config_len;
+	u16 dlen;
 	u8 tmp_buf[32];
 	int file_sz;
+	struct cfg_list_item *n;
+	struct list_head *pos, *next;
+	u8 chip_type;
 
 	config_lists_init();
 	patch_entry = dev_entry->patch_entry;
 	config_name = patch_entry->config_name;
 	udev = dev_entry->udev;
+	chip_type = patch_entry->chip_type;
 
 	RTKBT_INFO("config filename %s", config_name);
 	result = request_firmware(&fw, config_name, &udev->dev);
@@ -1332,56 +1358,105 @@ static int load_config(dev_data *dev_entry, u8 **buf, int *length)
 		return 0;
 
 	file_sz = fw->size;
-	len = fw->size;
-#ifndef USE_CONTROLLER_BDADDR
-	len += 9;
-#endif
+	buf = (u8 *)fw->data;
 
+	/* Load extra configs */
 	config_file_proc(EXTRA_CONFIG_FILE);
-	if (!list_empty(&list_extracfgs)) {
-		struct cfg_list_item *item;
-		struct list_head *tmp, *iter;
-
-		list_for_each_safe(iter, tmp, &list_extracfgs) {
-			item = list_entry(iter, struct cfg_list_item, list);
-			len += (item->len + 3);
-		}
+	list_for_each_safe(pos, next, &list_extracfgs) {
+		n = list_entry(pos, struct cfg_list_item, list);
+		RTKBT_INFO("extra cfg: ofs %04x, len %u", n->offset, n->len);
 	}
 
-	tbuf = kzalloc(len, GFP_KERNEL);
-	if (!tbuf)
-		goto err1;
-	memcpy(tbuf, fw->data, fw->size);
-
-#ifndef USE_CONTROLLER_BDADDR
+	/* Load extra bdaddr config */
 	memset(tmp_buf, 0, sizeof(tmp_buf));
 	result = request_bdaddr(tmp_buf);
-	if (result < 0) {
+	if (result > 0) {
+		n = kzalloc(sizeof(*n) + 6, GFP_KERNEL);
+		if (n) {
+			n->offset = get_mac_offset(patch_entry->chip_type);
+			n->len = 6;
+			memcpy(n->data, tmp_buf, 6);
+			list_add_tail(&n->list, &list_extracfgs);
+		} else {
+			RTKBT_WARN("Couldn't alloc mem for bdaddr");
+		}
+	} else {
 		if (result == -ENOENT)
 			RTKBT_WARN("no bdaddr file %s", BDADDR_FILE);
 		else
 			RTKBT_WARN("invalid customer bdaddr %d", result);
 	}
-	customer_bdaddr = (result < 0) ? false : true;
-#endif
-	len = rtk_parse_config_file(patch_entry, len, tbuf, file_sz, tmp_buf);
-	config_lists_free();
 
-	*buf = tbuf;
-	*length = len;
+	RTKBT_INFO("Origin cfg len %u", (u16)file_sz);
+	util_hexdump((const u8 *)buf, file_sz);
 
-	util_hexdump(*buf, *length);
+	result = rtk_parse_config_file(buf, file_sz);
+	if (result < 0) {
+		RTKBT_ERR("Parse config file error");
+		buf = NULL;
+		goto done;
+	}
 
-	release_firmware(fw);
+	merge_configs(&list_configs, &list_extracfgs);
 
-	RTKBT_INFO("Config file length %d, new length %d", file_sz, len);
+	/* Calculate the config_len */
+	config_len = 4; /* magic word length */
+	config_len += 2; /* data length field */
+	dlen = 0;
+	list_for_each_safe(pos, next, &list_configs) {
+		n = list_entry(pos, struct cfg_list_item, list);
+		switch (n->offset) {
+		case 0x003c:
+		case 0x0030:
+		case 0x0044:
+			if (is_mac(chip_type, n->offset) && n->len == 6) {
+				char s[18];
+				sprintf(s, "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X",
+					n->data[5], n->data[4],
+					n->data[3], n->data[2],
+					n->data[1], n->data[0]);
+				RTKBT_INFO("bdaddr ofs %04x, %s", n->offset, s);
+			}
+			break;
+		default:
+			break;
+		}
 
-	return 0;
-err1:
+		config_len += (3 + n->len);
+		dlen += (3 + n->len);
+	}
+
+
+	buf = kzalloc(config_len, GFP_KERNEL);
+	if (!buf) {
+		RTKBT_ERR("Couldn't alloc buf for configs");
+		goto done;
+	}
+
+	/* Save configs to a buffer */
+	memcpy(buf, cfg_magic, 4);
+	buf[4] = dlen & 0xff;
+	buf[5] = (dlen >> 8) & 0xff;
+	p = buf + 6;
+	list_for_each_safe(pos, next, &list_configs) {
+		n = list_entry(pos, struct cfg_list_item, list);
+		p[0] = n->offset & 0xff;
+		p[1] = (n->offset >> 8) & 0xff;
+		p[2] = n->len;
+		memcpy(p + 3, n->data, n->len);
+		p += (3 + n->len);
+	}
+
+	RTKBT_INFO("New cfg len %u", config_len);
+	util_hexdump((const u8 *)buf, config_len);
+
+	*length = config_len;
+
+done:
 	config_lists_free();
 	release_firmware(fw);
-	return -1;
 
+	return buf;
 }
 
 int load_firmware(dev_data * dev_entry, uint8_t ** buff)
@@ -1403,7 +1478,7 @@ int load_firmware(dev_data * dev_entry, uint8_t ** buff)
 	lmp_version = patch_entry->lmp_sub;
 	RTKBT_DBG("lmp_version = 0x%04x", lmp_version);
 
-	load_config(dev_entry, &config_file_buf, &config_len);
+	config_file_buf = load_config(dev_entry, &config_len);
 
 	fw_name = patch_entry->patch_name;
 	RTKBT_ERR("fw name is  %s", fw_name);
@@ -1414,6 +1489,7 @@ int load_firmware(dev_data * dev_entry, uint8_t ** buff)
 		config_file_buf = NULL;
 		goto fw_fail;
 	}
+
 	epatch_buf = kzalloc(fw->size, GFP_KERNEL);
 	if (NULL == epatch_buf)
 		goto alloc_fail;
diff --git a/nvidia/drivers/bluetooth/realtek/rtk_misc.h b/nvidia/drivers/bluetooth/realtek/rtk_misc.h
index 58874d3b4267..dbc56904ba2d 100644
--- a/nvidia/drivers/bluetooth/realtek/rtk_misc.h
+++ b/nvidia/drivers/bluetooth/realtek/rtk_misc.h
@@ -1,6 +1,4 @@
 /*
- *
- * Copyright (c) 2019-2020, NVIDIA CORPORATION. All rights reserved.
  *
  *  Realtek Bluetooth USB download firmware driver
  *
@@ -34,19 +32,20 @@
  * Download normal patch when host resume or power on */
 /* #define RTKBT_SWITCH_PATCH */
 
+/* RTKBT Power-on Whitelist for sideband wake-up by LE Advertising from Remote.
+ * Note that it's necessary to apply TV FW Patch. */
+/* #define RTKBT_TV_POWERON_WHITELIST */
+
 #if 1
-#define RTKBT_DBG(fmt, arg...) \
-			printk(KERN_DEBUG "rtk_btusb: " fmt "\n" ,## arg)
+#define RTKBT_DBG(fmt, arg...) printk(KERN_INFO "rtk_btusb: " fmt "\n" , ## arg)
 #define RTKBT_INFO(fmt, arg...) printk(KERN_INFO "rtk_btusb: " fmt "\n" , ## arg)
-#define RTKBT_WARN(fmt, arg...) \
-			printk(KERN_DEBUG "rtk_btusb: " fmt "\n" ,## arg)
+#define RTKBT_WARN(fmt, arg...) printk(KERN_WARNING "rtk_btusb: " fmt "\n", ## arg)
 #else
 #define RTKBT_DBG(fmt, arg...)
 #endif
 
 #if 1
-#define RTKBT_ERR(fmt, arg...) \
-			printk(KERN_DEBUG "rtk_btusb: " fmt "\n", ## arg)
+#define RTKBT_ERR(fmt, arg...) printk(KERN_ERR "rtk_btusb: " fmt "\n" , ## arg)
 #else
 #define RTKBT_ERR(fmt, arg...)
 #endif
@@ -77,6 +76,12 @@ extern int download_patch(struct usb_interface *intf);
 extern void print_event(struct sk_buff *skb);
 extern void print_command(struct sk_buff *skb);
 extern void print_acl(struct sk_buff *skb, int dataOut);
+
+#if defined RTKBT_SWITCH_PATCH || defined RTKBT_TV_POWERON_WHITELIST
+int __rtk_send_hci_cmd(struct usb_device *udev, u8 *buf, u16 size);
+int __rtk_recv_hci_evt(struct usb_device *udev, u8 *buf, u8 len, u16 opcode);
+#endif
+
 #ifdef RTKBT_SWITCH_PATCH
 #define RTLBT_CLOSE	(1 << 0)
 struct api_context {
@@ -85,9 +90,6 @@ struct api_context {
 	int			status;
 };
 
-int __rtk_send_hci_cmd(struct usb_device *udev, u8 *buf, u16 size);
-int __rtk_recv_hci_evt(struct usb_device *udev, u8 *buf, u8 len,
-		       u16 opcode);
 int download_lps_patch(struct usb_interface *intf);
 int set_scan(struct usb_interface *intf);
 
-- 
2.37.2

